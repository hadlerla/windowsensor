# ADR-014: WiFi State Machine & Mode Transitions

## Title
WiFi State Machine & Mode Transitions for Configuration and Operation

## Status
Proposed

## Context
Milestone M1 requires the device to operate in multiple WiFi modes (AP mode for configuration, Station mode for normal operation) with clear state transitions and user feedback (US01, US04). The device must handle boot scenarios, button-triggered mode changes, connection failures, and LED state synchronization.

Key requirements:
- Boot in AP mode if no WiFi credentials exist
- Boot in Station mode and connect if credentials exist
- Enter AP mode on button press (configurable duration)
- Provide visual feedback via RGB LED for each state
- Handle connection failures and timeouts
- Persist last successful connection state
- Integrate with FreeRTOS event-driven architecture (ADR-001)

Challenges:
- State transitions must be deterministic and traceable
- Concurrent operations (button monitoring, WiFi events, LED updates)
- Graceful handling of edge cases (AP mode timeout, disconnections during web config)
- Integration with future Matter protocol (M2 dependency)

## Alternatives

### Alternative 1: Simple Flag-Based State Tracking
- Use global state variables to track WiFi mode
- Handle transitions in main loop or scattered across multiple tasks
- **Pros:**
  - Simple to implement initially
  - Low overhead
- **Cons:**
  - Hard to maintain and debug
  - Prone to race conditions
  - Poor traceability
  - Difficult to extend for M2 (Matter integration)

### Alternative 2: Explicit State Machine with Event Queue (Recommended)
- Define explicit states: `WIFI_STATE_INIT`, `WIFI_STATE_AP_MODE`, `WIFI_STATE_CONNECTING`, `WIFI_STATE_CONNECTED`, `WIFI_STATE_DISCONNECTED`
- Use FreeRTOS event group and task to manage state transitions
- Process WiFi events (connection, disconnection) and user events (button press) via event queue
- Publish state changes to system event bus for LED and other components
- **Pros:**
  - Clear, maintainable state logic
  - Easy to debug and trace
  - Supports event-driven architecture (ADR-001)
  - Extensible for Matter protocol integration (M2)
  - Thread-safe with FreeRTOS primitives
- **Cons:**
  - More initial implementation effort
  - Slightly higher memory usage (event queue, state machine task)

### Alternative 3: Hierarchical State Machine (HSM)
- Use nested states with substates for complex transitions
- Implement using library like Quantum Platform (QP)
- **Pros:**
  - Handles very complex state logic
  - Formal verification possible
- **Cons:**
  - Overkill for this project
  - External dependency
  - Steeper learning curve

## Decision
**Choose Alternative 2: Explicit State Machine with Event Queue**

Rationale:
- Aligns with event-driven architecture (ADR-001)
- Provides clear state definitions and transitions
- Thread-safe using FreeRTOS event groups and queues
- Maintainable and debuggable
- Extensible for Matter integration in M2
- No external dependencies

State Machine Design:
```
States:
- WIFI_STATE_INIT: Startup, check for stored credentials
- WIFI_STATE_AP_MODE: Access Point mode, serving web configuration
- WIFI_STATE_CONNECTING: Attempting to connect to configured WiFi
- WIFI_STATE_CONNECTED: Successfully connected to WiFi
- WIFI_STATE_DISCONNECTED: Connection lost, attempting reconnection

Transitions:
INIT -> AP_MODE (no credentials)
INIT -> CONNECTING (credentials exist)
AP_MODE -> CONNECTING (credentials saved)
CONNECTING -> CONNECTED (success)
CONNECTING -> AP_MODE (timeout after retries)
CONNECTING -> DISCONNECTED (failure)
CONNECTED -> DISCONNECTED (connection lost)
DISCONNECTED -> CONNECTING (auto-retry)
DISCONNECTED -> AP_MODE (user button press)
CONNECTED/DISCONNECTED -> AP_MODE (button press)
```

Implementation approach:
1. Create `wifi_manager` component with dedicated FreeRTOS task
2. Use ESP-IDF WiFi event loop for connection events
3. Use FreeRTOS event group to signal state changes
4. Post state changes to system event loop for LED updates
5. Store last successful SSID in NVS for reconnection priority
6. Implement configurable retry logic (max attempts, backoff)
7. Use Kconfig for timeout and retry parameters (ADR-012)

## Consequences

**Positive:**
- Clear, traceable state management
- Thread-safe operation
- Easy integration with LED feedback and button handling
- Supports future Matter protocol integration
- Testable state transitions
- Proper error handling and recovery

**Negative:**
- Additional memory overhead (~2-4KB for task, queues, state machine)
- More initial implementation effort compared to simple flags
- Requires thorough testing of all state transitions

**Follow-up Actions:**
1. Define state transition diagram in documentation
2. Implement wifi_manager component structure
3. Define event types and event queue interface
4. Configure retry logic and timeouts in Kconfig (ADR-012)
5. Create unit tests for state machine logic (ADR-008)
6. Document state machine API for integration with other components

## References
- [ESP-IDF WiFi Driver Documentation](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/wifi.html)
- [ESP-IDF Event Loop Library](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/esp_event.html)
- [ADR-001: System Architecture](ADR-001.md) - Event-driven design
- [ADR-012: Compile-Time Configuration](ADR-012.md) - Kconfig for timeouts/retries
- [US01: WiFi Configuration via AP Mode](../stories/US01_wifi_ap_mode.md)
- [US04: RGB LED State Indication](../stories/US04_rgb_led_state.md)
