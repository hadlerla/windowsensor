# ADR-016: RGB LED Control Architecture

## Title
RGB LED Control Architecture for State Indication

## Status
Proposed

## Context
Milestone M1 requires visual feedback via RGB LED to indicate device WiFi state (US04). The LED must display different colors and patterns for different states:
- Blue blinking: AP mode
- Red blinking: Disconnected (no WiFi)
- Green blinking: Connected to WiFi

Future milestones (M2) will add Matter states. The LED control must be:
- Integrated with WiFi state machine (ADR-014)
- Non-blocking (not interfere with other operations)
- Extensible for additional states and patterns
- Power-efficient
- Hardware-abstracted (ADR-002)

Hardware: ESP32-C6 has built-in WS2812 RGB LED (addressable LED strip protocol)

Challenges:
- Non-blocking pattern generation (blink timing)
- Synchronization with state machine
- Memory efficiency for pattern definitions
- Priority handling (error states should override normal states)

## Alternatives

### Alternative 1: Blocking Delay-Based LED Control
- Use `vTaskDelay()` in state machine or main loop to toggle LED
- Simple state-to-color mapping
- **Pros:**
  - Very simple to implement
  - Minimal code
- **Cons:**
  - Blocks task execution during delays
  - Cannot handle concurrent states
  - Poor responsiveness
  - Hard to extend for complex patterns

### Alternative 2: Dedicated LED Task with Pattern Queue (Recommended)
- Create dedicated `led_controller` component with FreeRTOS task
- Subscribe to WiFi state change events from system event loop
- Define LED patterns as structs (color, blink rate, duration)
- Use timer-based non-blocking state machine for pattern execution
- Support pattern priorities (error states override normal states)
- **Pros:**
  - Non-blocking, runs independently
  - Clean separation of concerns
  - Extensible pattern definition
  - Supports priorities and transitions
  - Aligns with event-driven architecture (ADR-001)
- **Cons:**
  - More implementation effort
  - Additional task overhead (~1-2KB)

### Alternative 3: Hardware Timer-Based PWM LED Control
- Use ESP32 hardware timer and LED PWM peripheral
- Configure timer interrupts for pattern timing
- **Pros:**
  - Minimal CPU overhead
  - Very precise timing
- **Cons:**
  - More complex for RGB LED control
  - WS2812 protocol requires bit-banging or RMT, not simple PWM
  - Overkill for simple blink patterns

## Decision
**Choose Alternative 2: Dedicated LED Task with Pattern Queue**

Rationale:
- Non-blocking design fits event-driven architecture (ADR-001)
- Clean abstraction separates LED logic from state machine
- Extensible for M2 Matter states
- Pattern-based approach is maintainable and testable
- Supports smooth transitions and priorities

LED Pattern Definition:
```c
typedef enum {
    LED_PATTERN_OFF,
    LED_PATTERN_SOLID,
    LED_PATTERN_BLINK_SLOW,   // 1 Hz
    LED_PATTERN_BLINK_FAST,   // 2 Hz
    LED_PATTERN_PULSE,        // Fade in/out
} led_pattern_t;

typedef struct {
    uint8_t red;
    uint8_t green;
    uint8_t blue;
    led_pattern_t pattern;
    uint8_t priority;  // Higher priority overrides lower
} led_state_t;

// State-to-LED mapping (from US04)
AP_MODE:        { 0, 0, 255, BLINK_SLOW, PRIORITY_NORMAL }     // Blue blink
DISCONNECTED:   { 255, 0, 0, BLINK_SLOW, PRIORITY_NORMAL }     // Red blink
CONNECTED:      { 0, 255, 0, BLINK_SLOW, PRIORITY_NORMAL }     // Green blink
ERROR:          { 255, 0, 0, BLINK_FAST, PRIORITY_HIGH }       // Red fast blink
```

Implementation approach:
1. Create `led_controller` component with dedicated FreeRTOS task
2. Task runs at 100 Hz (10ms period) for pattern timing
3. Subscribe to `WIFI_STATE_CHANGED` events from system event loop
4. Map WiFi states to LED patterns using lookup table
5. Use `led_strip` driver (already in project) for WS2812 control
6. Implement pattern state machine within LED task (time-based toggling)
7. Support smooth transitions between patterns (optional fade)
8. Configure LED GPIO pin via Kconfig (ADR-012)

## Consequences

**Positive:**
- Non-blocking, responsive LED control
- Clean separation of LED logic from application logic
- Extensible for future states and patterns
- Testable in isolation
- Follows event-driven architecture
- Power-efficient (LED task sleeps when not updating)

**Negative:**
- Additional FreeRTOS task (~1-2KB RAM overhead)
- More initial implementation effort
- Pattern timing accuracy depends on task scheduling (acceptable for visual feedback)

**Follow-up Actions:**
1. Implement `led_controller` component structure
2. Define LED pattern struct and state mapping table
3. Create LED task with pattern state machine
4. Subscribe to WiFi state events
5. Configure LED GPIO in Kconfig (ADR-012)
6. Add unit tests for pattern generation (ADR-008)
7. Document LED pattern API for future extensions

**Power Considerations:**
- LED brightness configurable via Kconfig (ADR-012)
- Consider dimming or disabling LED in battery mode (future)
- WS2812 draws ~5mA per LED at low brightness

## References
- [ESP-IDF LED Strip Driver](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/led_strip.html)
- [ESP-IDF FreeRTOS Documentation](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/freertos.html)
- [ADR-001: System Architecture](ADR-001.md) - Event-driven design
- [ADR-002: Hardware Abstraction](ADR-002.md) - HAL for peripherals
- [ADR-012: Compile-Time Configuration](ADR-012.md) - Kconfig for LED settings
- [ADR-014: WiFi State Machine](ADR-014.md) - State events
- [US04: RGB LED State Indication](../stories/US04_rgb_led_state.md)
